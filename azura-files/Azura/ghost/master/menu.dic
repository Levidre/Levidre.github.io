//---------------------------Menus--------------------------
//This .dic file is primarily concerned with the double-click menus for each of your ghosts. If you don't want to have menus for your characters, you'd just have to delete the OnMouseDoubleClick functions near the end of mouse.dic and then ignore this file, as none of it will be called I believe. Menus can be cool though, since you can put stuff in them and create new functions if you know what you're doing. For example, I've added a lot of games and interactions and little linked icons to my Hunter Smoker ghost to keep track of their feelings and such. Much of that is pretty complicated though (and kind of messy, cough), so I won't go into it here, but I covered some of the concepts in the coding page of the walkthrough, and enterprising ghost makers can study the menu.dic file I set up for Hunter/Smoker and see how I put it together.
//Anyway, menu.dic also contains the settings for a config menu that will let your user change their name or pronouns if they want, as well as the talk rate of the ghost, all of which are useful things for your ghost to do. So think hard about whether or not you want to skip this file or not.

//The complexity of this file depends on how customized you want your menus. If you just want to leave them as they are, then all you'll have to do is replace dialogue appropriately. You can always add stuff to their menus later if you get the urge. Otherwise, if you have plans in mind, you'll need to study what's going on in here carefully and pay attention to how things are set up! You can do a lot of unique stuff in this file if you're creative.

//Make sure to read the walkthrough (http://www.ashido.com/ukagaka/walkthrough.html) for more details about how to properly format ghost dialogue!
//I will reiterate that you should be editing these in Notepad++, and in particular, you should set the Language to C (or Java I guess) to properly highlight all the text. It will make things A LOT EASIER for you, trust me! It will also help you keep track of your brackets in case you forget some. If you click on a line with a bracket in Notepad++, it should highlight where the other bracket ends, or turn purple if there's no finishing bracket (which you should definitely fix!)
//It will also highlight my commented lines in green, so you'll know where they are. Any line beginning with // is a commented line that the code will not read. It's just for your reference!


//--OpenSakuraMenu
//This is a bit of intro dialogue before the main character opens their menu. You can see below that there are three pieces of separate dialogue listed before it goes to MenuRun. The character will randomly choose one of those pieces of dialogue before opening the rest of their menu. You can customize this with individual greetings for the character, such as "Yes, %(username)?" or "Need something, %(username)?" or things like that. Note that none of the lines end with \e!
//The \b2 tag tells the ghost to use their big balloon for this dialogue. If your menu has a lot of stuff, this'll probably look better than the small one.

OpenSakuraMenu
{
	
		/* if inpyjama == 1
		{
			"\0\s[20]\1\s[1]"
		}
		else
		{
			"\0\s[10]\1\s[1]"
		} */
		--
		"\0\b2%(lsto)"
		--
		if asleep != 1
		{
			"* Yes ?"
			"* What do you want ?"
			"* Want something ?"
			"* Yep ?"
		}
		else
		{
			"* Mmh..."
			"* Zzz..."
		}
		--
		truc =0
		much = IARRAY
		MenuRun
}

//--MenuRun
//As you just saw above. This actually fills out the rest of the menu. If you're going to be adding or changing functions, this is where you'll be doing your edits.

MenuRun
 {	
 	wd = GetWeekDay
 	ap = GetAP
 	nowmin = Getnowmin
 	nowhour = Getnowhour
	//These four statements basically get the day of the week, whether it's AM or PM, the hour, and the time. It's putting together the information to display the time at the bottom of the balloon. Pay it no mind.
	--
	"\n\n\_q\b2" //The \n\n means two new lines as detailed in the walkthrough, and \_q means quick session, meaning all the text from this point on will display instantly instead of a few letters at a time like normal ghost dialogue.
	--
	"\f[italic,true]You may want to interact with her :\f[italic,false]\n\n[half]"
	--
	if lastTalk != "" //What this does is check to see if the ghost has already said a random bit of dialogue on its own, essentially by seeing if the lastTalk thing is NOT empty (!= means "does not equal").
	{
	  "\![*]\q[Repeat Last Dialogue,OnLastTalk]\n"
	  //If the ghost has said something, it will then display this menu option. You can replace "Repeat Last Dialogue" with whatever caption you like, such as "What were you saying?" or "What did you say?" or "Could you repeat that?" or something like that.
	  
	  //*********************Advanced User Info*******************************
	  //These text boxes are meant for those who have an interest in expanding or using more complicated functions in their ghost. Also for my own reference in the future since I plan on using this template too, haha. If you have no interest in any of this and just want to keep things as simple as possible, feel free to skip these boxes.
	  
	  //I briefly touched in bootend.dic about \q, but I'll again cover it here. Pay very close attention to how this bit of dialogue is formatted. You'll see it goes \![*]\q[Displayed Name,linkedfunction]. Breaking it down, \![*] puts the balloon's option icon in front of the choice (usually a > or something), \q sets up the choice, Displayed Name which is the text that will display in the ghost's balloon, then linkedfunction, which is what the choice is linked to when the user clicks it. As you go through this file, look at how every menu option is set up, and you will see they all follow this format, give or take a \![*]. If you're going to be adding new options to menus or creating your own functions and such, make sure you follow this format and learn it well. Make sure to read the coding page of the walkthrough.
	  //***********************************************************************
	}
	--
 	"\![*]\q[Say something,altalk]\n"	
	//This option will force the ghost to say something from aitalk if the user clicks it. Just replace "Say something" and "Say something 2" with whatever captions you think would be appropriate for such an option. IF you don't want two options for captions, delete one of the lines.
	//Advanced users, you can add multiple captions for any option you add to a menu you make just like this, as long as you separate it from the other options into its own section with two dashes above and below.
	--
	//You would be able to say her all you want but she doesn't understand anything else than food yet.
	if asleep != 1
	{
		"\![*]\q[You want to say her something,saysthg]\n"
		--
		"\![*]\q[You want to ask her something,asksthg]\n\n[half]"
		
		--
		"\![*]\q[ACT,actmenu]    \![*]\q[ITEM,itmenu]\n"
	}	
	--
	"\n\f[italic,true]You may want to ask her a favor :\f[italic,false]\n\n[half]"
	--
	if asleep != 1
	{
		"\![*]\q[Hear music,Musicmenu]"
		--
		if askedanime == 1 && askedbooks == 1 && askedgame == 1
		{
			"    \![*]\q[Play a fight game,enterfight]\n"
		}
		else
		{
			"\n"
		}
		--
		if helping == 1
		{
		"\![*]\q[Todo list,todolist]     "//" \![*]\q[Tell her your true self,trueself]"
		}
		--
		"\![*]\q[Help or explanations,helpmenu]\n"
		--
		if enablebackup == 1
		{
			"\![*]\q[Backup,BackupMenu]\n"
		}
		--
	}
	else
	{
		"\![*]\q[Wake her up,WakeUp]\n"
	}
	--
	if displaytest == 1
	{
		"\n[half]\f[italic,true]The test functions and some useful things :\f[italic,false]\n\n[half]"
		--
		"\![*]\q[Call the test function,testfunction]\n"
		--
		"\![*]\q[Saori test menu,SaoriTestMenu]\n"
		--
		"\![*]\q[Explain how loops work,loopmenu]\n"
		--
		"\![*]\q[Call the second test function,othertestfunction]\n"
		--
		"\![*]\q[Display some variables,displayvariables]\n"
		--
		"\![*]\q[Reinitilize some variables,reinivariables]\n"
		--
		"\![*]\q[Find a word in the vocabulary,findvocabulary]\n"
	}
	--
	message = 0
	--
	"\n[half]\![*]\q[Config Menu,configmenu]    /
	\![*]\q[Functions,dosomething]\n\n[half]/
 	\![*]\q[Nevermind,CANCEL]\n\n\n[half]%(wd) %(nowhour):%(nowmin) %(ap), %(month)/%(day)/%(year)"
	--
	"\e"
	--
	SAVEVAR
	//These three lead to the Config Menu, the Function menu, and Cancel. You can leave these alone if you like. All the envelopes at the end (see word.dic) basically display the year, month, day, weekday, and time.
}

//Would run whatever you want.
Select.testfunction
{
	_i = FENUM("C:/Users/lisou/Documents/TP info ensisa/\\2A\\")
	"\_?%(_i)"
}
Ontest2function
{
	"%(Select.testfunction)"

}

GetShells
{
  _shellsnames = IARRAY
  _paths = FENUM("..\..\shell")
  foreach _paths ; _p
  {
    if FOPEN(_filename = "..\..\shell\%(_p)\descript.txt","r")
    {
    while (_line = FREAD(_filename)) != -1;
    {
      if CUTSPACE(_line[0]) == "name"
      { 
        _shellsnames ,= CUTSPACE(_line[1])
        break;
      }
    }
	FCLOSE(_filename)
	}
	
  }
  _shellsnames
}

//jedi, pokemon, artist, warrior, cat, furry, alien, spectrobe, ghost, monster, darkner, killer, student, kid, shape-shifter, responsible adult, a werewolf, a dragon, an unicorn, a boss, an ingineer, a faery, a dwarf, an elf, ogre, an intern, a business man, a seller, a worker, ninja
OnDestroy
{
	//UNLOADLIB("saori_test.dll")
}

OnKeyDetected
{
	"* received"
}

Select.othertestfunction
{
	//"\0%(lsta)You give her a slice of butterscotch-cinnamon pie. %(azpose)\i[58]\![embed,OnStartEating,pie]She seems so happy.%(lsto)\n\n[half]\0* Thank you very much, \w5I love butterscotch-cinnamon pies.\n\n[half]\f[italic,true]She starts to eat it.\f[italic,false]\e"
	//CreateAscii
	//i = SAORI("saori_test.dll","remove","OnKeyDetected")
	_i = FOPEN("test.txt","w")
	foreach intervalslist ; _interval
	{
		_i = FWRITE("test.txt","%(_interval)")
	}
	_i = FCLOSE("test.txt")
}

Select.displayvariables
{
	battlestatsize = ARRAYSIZE(battlestat)
	--
	--
	"%(lsto)* For now I display "
	--
	"issat = %(issat) oncomputer = %(oncomputer) isdrawing = %(isdrawing)\nbattlestatsize = %(battlestatsize)"
	--
	//"message = %(message)    surface = %(surface)"
	--
	//"    topghost = %(nameslib[1])    balloons = %(balloonlist)"
	--
	//"\n* But you can display what you want, like variables brought from other ghosts or the variables used by some functions."
	--
	SAVEVAR
	--
	"\e"
	
}

//It would reinitialize some variables then display the menu.
Select.reinivariables
{
	sleepingtime = 3
	azpunched = 0
	--
	MenuRun
}

OnVoiceRecognitionWord
{
	_wordsayed=reference1
	if SRmode == "disabled"
	{
		"\e"
	}
	elseif SRmode == "partial"
	{
		
		if _wordsayed == "Music_Player"
		{
			Select.SpeechRecognitionMenu
		}
		elseif _wordsayed == "Azura"
		{
			"\e"
		}
		else
		{
			if reference1 == "Previous"
			{
				"\![raise,OnChoiceSelect,previousmu]\e"
			}
			elseif reference1 == "Next"
			{
				"\![raise,OnChoiceSelect,nextmu]"
			}
			elseif reference1 == "Pause"
			{
				"\![raise,OnChoiceSelect,pausemu]\e"
			}
			elseif reference1 == "Play"
			{
				"\![raise,OnChoiceSelect,playmu]\e"
			}
			elseif reference1 == "Stop"
			{
				"\![raise,OnChoiceSelect,playmu]\e"
			}
			elseif reference1 == "Nothing"
			{
				"\e"
			}
		}
	}
	elseif reference0 == 1
	{
		if _wordsayed == "Music_Player"
		{
			Select.SpeechRecognitionMenu
		}
		elseif reference1 == "Previous"
		{
			"\![raise,OnChoiceSelect,previousmu]\e"
		}
		elseif reference1 == "Next"
		{
			"\![raise,OnChoiceSelect,nextmu]"
		}
		elseif reference1 == "Pause"
		{
			"\![raise,OnChoiceSelect,pausemu]\e"
		}
		elseif reference1 == "Play"
		{
			"\![raise,OnChoiceSelect,playmu]\e"
		}
		elseif reference1 == "Stop"
		{
			"\![raise,OnChoiceSelect,playmu]\e"
		}
		elseif reference1 == "Nothing"
		{
			"\e"
		}
	}

}

Select.close
{
	"\![leave,passivemode]\e"
}

Select.WakeUp
{
	DecreasePositiveAction
	"\0\f[italic,true]You touch her to wake her up.\f[italic,false]\n\n[half]\w8* Hmmnhm \w1.\w1.\w1.\![embed,OnSleep2E]\w7 Huh,\w5 %(username) ?\n\n[half]\f[italic,true]She doesn't seem very awake...\f[italic,false]\n\n[half]* How many time have I sleep ?"
}
//The menu for the explanations of loops
Select.loopmenu
{
	"%(lsto)* Which loop do you want me to explain ?\n\n[half]\_q"
	--
	"\![*]\q[A foreach one,expforeach]    \![*]\q[A while one,expwhile]"
}

Select.expforeach
{
	//Create the array
	myarray = IARRAY
	myarray[0] = "potatoes,chips"
	myarray[1] = "tomato,ketchup"
	myarray[2] = "bread,pie"
	--
	"\b2%(lsto)* I defined an array, it looks like :\n'' potatoes , chips ''\n'' tomato , ketchup ''\n'' bread , pie ''"
	--
	//Initialize the index to 0
	index = 0
	--
	"\n\n[half]* I start the foreach loop, the index is 0.\n"
	--
	//Initialize what will be displayed to an empty string, a chain of characters
	explainationsdisplayed = ""
	--
	"* There is a little problem with a foreach loop,\w5 if I try to display something during the loops,\w5 it would only display one randomly.\w7 So I stock each loop the dialogue I should have displayed in a big chain of characters I display after the foreach loops.\n\n[half] "
	--
	//The foreach, finally, line becomes each line of myarray one after the other
	foreach myarray ; line
	{	
		--
		//Each loop, the dialogue of what Azura does is added to what would be displayed at the end
		explainationsdisplayed = explainationsdisplayed + "* A loop : for now, line is %(line), the first element of line is %(line[0]) and the index of line in myarray is %(index)\n"
		--
		if index == 0
		{
			explainationsdisplayed = explainationsdisplayed + "* It was the first loop.\n"
		}
		--
		index = index + 1
		--
		if index == ARRAYSIZE(myarray)
		{
			explainationsdisplayed = explainationsdisplayed + "* It was the last loop, index is now equal to the size of myarray."
		}
	}
	--
	//Now, Azura display what she did during the loops
	"%(explainationsdisplayed)\x\e"
}

Select.expwhile
{
	"\b2%(lsto)* A little explanation is a necessity for those.\w7 While loops are very versatile but dangerous too. \w7They are the most dangerous loops that exist because they can be infinite. \w7That means they can run forever without ending, \w5so it could be assimilate to a crash. \w7While loops run while a condition is true and stop when it become false, \w5a condition that never become false will make the loops run forever.\n"
	--
	"* So what looks like this while loops ? \w7Something easy, \w5it looks like if-else statements. \w7It's like if the condition is true, \w5continue the loops. \w7Normally, a if statement runs once, \w5but a while will restart the loop until it leads to an else.\n"
	--
	"* For what using while loops ? Well, \w5what you want, \w5I'm myself using it to read, load or save files.\n\n[half]"
	--
	"\f[italic,true]You have the feeling a good example is in the function under this one or there is a little more complicated one in commu.dic. The function under this one isn't called by anything yet but it does a list of all the ascii code (the alphabet in computer language) used by ssp, it doesn't do anything else and isn't used by anything, but it was fun to do."
	--
	"\nThe one in commu.dic has a real utility, it serves for the interaction with other ghosts. What should do Azura is looking into the saving file of the other ghost to find a certain variable to know if the ghost is speaking or not. It's not finished yet though, it still checks the wrong variable.\f[italic,false]\n\n[half]"
	--
	"* I will do a very simple while loop,\w5 the condition will be a number under ten, \w5when this number would be superior than 10,\w5 the loops will stop and I display the number.\n\n[half]"
	--
	"* So I initialyze the number nb to 0 before starting the loops. \w7Each loop, \w5I increment nb of 1.\n"
	--
	nb = 0
	while nb <= 10
	{
		nb = nb + 1
	}
	--
	"\w8* Done, \w5and now nb is %(nb).\x\e"
	
}

CreateAscii
{
	codeascii = IARRAY
	_f = FOPEN("code asciidef.txt","r")
	letter = FREAD("code ascii.txt")
	
	while _i < 100
	{
		codeascii ,= letter 
		letter = FREAD("code ascii.txt")
		_i = _i + 1
	}
}

//Leave this next bit alone.
//Advanced users, note that this is formatted as Select.linkedfunction? Remember how it went \q[Displayed Name,linkedfunction] above? When a user clicks an option that doesn't begin with On, they'll be linked to Select.linkedfunction. Pay close attention as we go through and you'll see this in action.
Select.altalk
{
	AiTalk
}

//Leave this alone
OnLastTalk 
{
"%(lastTalk)\e"
}

//This is figuring out what day of the week it is. Leave it alone.
GetWeekDay
{
	if weekday == 0
	{"Sun"}
	elseif weekday == 1
	{"Mon"}
	elseif weekday == 2
	{"Tue"}
	elseif weekday == 3
	{"Wed"}
	elseif weekday == 4
	{"Thu"}
	elseif weekday == 5
	{"Fri"}
	else
	{"Sat"}
}

//This is finding out whether it's AM or PM. Leave it alone.
GetAP
{
 	if hour >= 0 && hour <= 11
 		{
 			"AM"
 		}
 	else
 		{
 			"PM"
 		}
}

//This is figuring out the minute. Leave it alone.
Getnowmin
{
	if minute >= 0 && minute <=9
		{
			"0%(minute)"
		}
	else
		{
			"%(minute)"
		}
}

//This is figuring out the hour. Leave it alone.
Getnowhour
{
	if hour12 >= 0 && hour12 <=9
		{
			"0%(hour12)"
		}
	else
		{
			"%(hour12)"
		}
}

//If someone selects an option linked to BACKTOMENU, it will go back to MenuRun.

Select.BACKTOMENU
	{
		MenuRun
	}

//If someone selects configmenu, this will lead to TalkConfig.
Select.configmenu
{
	//TalkConfig
	"\0\b[2]\_q%(lsta)What settings ?%(lsto) :\n\n[half]"
	--
	"\![*]\q[Your information,userinfos]\n"
	--
	"\![*]\q[Azura's settings,azsettings]\n"
	--
	"\![*]\q[Other settings,othersettings]"
	--
	"\n\n[half]\![*]\q[Go back,BACKTOMENU]     \![*]\q[Nevermind,close]"
}

Select.userinfos
{
	"\0\b2\_q%(lsta)Your information : \n\n[half]\f[italic,false]"
	--
	"\![*]\q[Change your name,TEACHNAME] \n        \f[italic,true](currently %(username))\f[italic,false]\n/
	\![*]\q[Change your pronouns,TEACHPRONOUN] \n        \f[italic,true](currently %(heshe)/%(himher)/%(hisher))\f[italic,false]\n/
	\![*]\q[Change your birthday,TEACHBDAY] \n        \f[italic,true](currently %(birthdayprint))\f[italic,false]"
	--
	if trueself != ""
	{
		"\n\![*]\q[Change you identity,revealself]\n        \f[italic,true](currently %(trueself))\f[italic,false]"
	}
	--
	"\n\n[half]\![*]\q[Go back,configmenu]     \![*]\q[Back to the menu,BACKTOMENU]\n\![*]\q[Nevermind,close]"
}

Select.azsettings
{
	"\0\b2\_q%(lsta)Azura's settings : \n\n[half]\f[italic,false]"
	--
	"\![*]\q[Change the talk rate,talkinter] \n        \f[italic,true](currently %(talktime))\f[italic,false]\n/
	\![*]\q[Change the battle mode,battlemode]\n        \f[italic,true](currently "
	--
	if hardbattle == 1
	{
		"hard"
	}
	else
	{
		"normal"
	}
	--
	")\f[italic,false]\n\![*]\q[Enable self-learning,selflearn] \n        \f[italic,true]"
	--
	if selflearning == 1
	{
		"(currently yes)"
	}
	else
	{
		"(currently no)"
	}
	--
	"\f[italic,false]\n/
	\![*]\q[Reinitialize her vocabulary,reinivoc]\n/
	\![*]\q[Switch to the "
	--
	if nowshell == "Old shell"
	{
		"new"
	}
	else
	{
		"old"
	}
	--
	" shell,changeshellver]\n/
	\![*]\q[Reset Azura,ResetRelation]\n        \f[italic,true](WARNING: cannot be undo)\f[italic,false]"
	--
	"\n\n[half]\![*]\q[Go back,configmenu]     \![*]\q[Back to the menu,BACKTOMENU]\n\![*]\q[Nevermind,close]"
}

Select.othersettings
{
	"\0\b2\_q%(lsta)Other settings : \n\n[half]\f[italic,false]"
	--
	"\![*]\q[Set the voice recognition,SRset]\n        \f[italic,true](currently %(SRmode) mode)\f[italic,false]\n/
	\![*]\q[Enable music player keyboard controls,enablekey] \n        \f[italic,true](currently %(muhotkey))\f[italic,false]\n/
	\![*]\q[Displaying keyboard controls,displaykeyboard]\n        \f[italic,true]"
	--
	if muprecision != 0
	{
		"(currently yes)"
	}
	else
	{
		"(currently no)"
	}
	--
	"\f[italic,false]\n\![*]\q[Enable Uninstall,deleteonoff] \n        \f[italic,true](currently %(deleteshitai))\f[italic,false]\n/
	\n[half]\![*]\q[Enable the tests,enabletest]\n/
	\![*]\q[Open SSP preferences,sspconfig]"
	--
	"\n\n[half]\![*]\q[Go back,configmenu]     \![*]\q[Back to the menu,BACKTOMENU]\n\![*]\q[Nevermind,close]"
}

//*********************Advanced User Info*******************************
//Some of you may be wondering why some of these Select.options lead to another function. Why not just put the config menu coding under Select.configmenu, instead of linking to TalkConfig?
//Basically any function that's preceded with Select. is limited in its complexity and can only be called within its own .dic file in my experience. Why should you care, you ask? Well, if you're going to link to this function any other way, such as linking it in other .dic files or as a page in a menu, it needs to be a stand-alone function so it can be properly called. I'm pretty sure.
//The basic jist is this; if you're going to reuse whatever it is the option leads to, you should make it its own function. Otherwise, you can leave it in Select.option. As a rule of thumb I'd probably put any complicated stuff in its own function, then use the Select.option to call the full function as you can see above. Simple dialogue responses to a choice can stay as a Select.option though. Study what stays as a Select.option and what links to another Function as we go through the file.
//***********************************************************************

//--TalkConfig
//This menu allows the user to change their name and other information, as well as put in their birthday and change how often the ghost speaks. You shouldn't need to touch any of what's under TalkConfig, although you can adjust dialogue in the following functions related to it.

TalkConfig
{
	//This bit of dialogue sets up a large balloon and a quick session, like above, so all the text will appear immediately. The rest is formatted to display the information and options to change it. I wouldn't touch any of it if you don't know what you're doing.
	//I'll briefly explain the font tags I used here. \f[bold,1] turns bold on, \f[bold,0] turns it off, not unlike a <b> tag. \f[sup,1] turns superscript on (making it tiny and above the text) and \f[sup,0] turns it off. I touch on these tags in the walkthrough on SakuraScript.
	"\0\b[2]\_q%(lsta)Global settings%(lsto) :\n\n[half]"
	--
	"\![*]\q[Change your name,TEACHNAME] \n        \f[italic,true](currently %(username))\f[italic,false]\n/
	\![*]\q[Change your pronouns,TEACHPRONOUN] \n        \f[italic,true](currently %(heshe)/%(himher)/%(hisher))\f[italic,false]\n/
	\![*]\q[Change your birthday,TEACHBDAY] \n        \f[italic,true](currently %(birthdayprint))\f[italic,false]\n/
	\![*]\q[Change the talk rate,talkinter] \n        \f[italic,true](currently %(talktime))\f[italic,false]\n/
	\![*]\q[Change the battle mode,battlemode]\n        \f[italic,true](currently "
	--
	if hardbattle == 1
	{
		"hard"
	}
	else
	{
		"normal"
	}
	--
	")\f[italic,false]\n\![*]\q[Enable Uninstall,deleteonoff] \n        \f[italic,true](currently %(deleteshitai))\f[italic,false]\n/
	\![*]\q[Reset Azura,ResetRelation]\n        \f[italic,true](WARNING: cannot be undo)\f[italic,false]\n/
	\![*]\q[Open SSP preferences,sspconfig]\n\n[half]/
	
	\![*]\q[Back to the menu,BACKTOMENU]"
	--
	"\1\b2%(lsta)Particular settings :%(lsto)\n\n[half]"
	--
	"\![*]\q[Enable music player keyboard controls,enablekey] \n        \f[italic,true](currently %(muhotkey))\f[italic,false]\n/
	\![*]\q[Displaying keyboard controls,displaykeyboard]\n        \f[italic,true]"
	--
	if muprecision != 0
	{
		"(currently yes)"
	}
	else
	{
		"(currently no)"
	}
	--/*
	"\![*]\q[Renaming the songs,renameset]\n        \f[italic,true]"
	--
	if renamingsong == 1
	{
		"(currently yes)"
	}
	else
	{
		"(currently no)"
	}*/
	"\f[italic,false]\n\![*]\q[Set the voice recognition,SRset]\n        \f[italic,true](currently %(SRmode) mode)"
	--
	"\f[italic,false]\n\![*]\q[Enable self-learning,selflearn] \n        \f[italic,true]"
	--
	if selflearning == 1
	{
		"(currently yes)"
	}
	else
	{
		"(currently no)"
	}
	--
	"\f[italic,false]\n/
	\![*]\q[Reinitialize her vocabulary,reinivoc]\n/
	\![*]\q[Switch to the "
	--
	if nowshell == "Old shell"
	{
		"new"
	}
	else
	{
		"old"
	}
	--
	" shell,changeshellver]\n/
	\![*]\q[Enable the tests,enabletest]\n\n[half]/
	\![*]\q[Back to the menu,BACKTOMENU]\e"
	
	
}


Select.changeshellver
{
	
	if nowshell == "Old shell"
	{
		azpose = "\0\s[10]%(smile)"
		if dayslot != "11month 1day" && dayslot != "10month 31day"
		{
			if inpyjama == 1
			{
				"\![change,shell,Pyjama shell]\e"
			}
			else
			{
				"\![change,shell,Normal shell]\e"
			}
		}
		elseif nowshell != "Halloween shell"
		{
			"\![change,shell,Halloween shell]\e"
		}
	}
	else
	{	
		"\![change,shell,Old shell]\e"
		if dayslot != "11month 1day" && dayslot != "10month 31day"
		{
			if inpyjama == 1
			{
				azpose = "\0\s[20]%(smile)"
			}
			else
			{
				azpose = "\0\s[10]%(smile)"
			}
		}
		else
		{
			azpose = "\0\s[30]%(smile)"
		}
	}
}

Select.battlemode
{
	if hardbattle == 1
	{
		hardbattle = 0
		"\0\i[10]%(lsto)* I guess you want to win sometimes.\e"
	}
	else
	{
		hardbattle = 1
		"\0\i[13]%(lsto)* So you wanna have a bad time ? \w7\i[10]Fine.\e"
	}
}

Select.emailsettings
{
	"\![open,configurationdialog]"
}

Select.enabletest
{
	if displaytest == 1
	{
		if asleep != 1
		{
			"\0%(lsto)* The tests wouldn't show up."
		}
		else
		{
			"\0%(lsto)* Zzz...\n\n[half]\f[italic,true]The tests wouldn't show up.\f[italic,false]"
		}
		--
		displaytest = 0
	}
	else
	{
		if asleep != 1
		{
			"\0%(lsto)* The tests would be displayed."
		}
		else
		{
			"\0%(lsto)* Zzz...\n\n[half]\f[italic,true]The test would be displayed.\f[italic,false]"
		}
		--
		displaytest = 1
	}
	--
	"\e"
}

Select.selflearn
{
	if selflearning == 1
	{
		selflearning = 0
		"\0%(lsta)You would teach yourself Azura new words."
	}
	else
	{
		selflearning = 1
		"\0%(lsta)Azura would learn the new words by herself."
	}
	
}

Select.displaykeyboard
{
	if muprecision != 0
	{
		muprecision=0
		"\0%(lsta)It's a gain of place for sur.\e"
	}
	else
	{
		muprecision=1
		"\0%(lsta)So you won't forget them.\e"
	}
}

Select.renameset
{
	if renamingsong == 1
	{
		renamingsong = 0
		"\0%(lsta)The songs won't be renamed in the playlist."
	}
	else
	{
		renamingsong = 1
		"\0%(lsta)The songs would be renamed when putting in the playlist (the files aren't renamed)."
	}
}

Select.SRset
{
	"%(lsto)* What mode do you want ?\n\n[half]\_q"
	--
	"\![*]\q[The full mode,SRfull]\n\![*]\q[Only the music player vocal commands,SRpartial]\n\![*]\q[Disable it completely,SRdisable]\e"
}

Select.SRsetVR
{
	"\_q%(lsto)* What mode do you want ?\n\n[half]"
	--
	"\![*]\q[Full mode,SRfull]\n\![*]\q[Partial mode,SRpartial]\n\![*]\q[Disabled mode,SRdisable]\e"
}

Select.SRfull
{
	"%(lsto)* Everything would work with the voice recognition.\e"
	SRmode="full"
}
Select.SRpartial
{
	"%(lsto)* Only the music player choices would work with the voice recognition.\e"
	SRmode = "partial"
}
Select.SRdisable
{
	"%(lsto)* The voice recognition is disabled for me.\e"
	SRmode = "disabled"
}

//This and the next few set up the pronouns, as you can see by the linkedfunction names. You can replace "\0\s[0]What pronouns do you want?" with your own dialogue if you prefer, but leave the rest of it alone.

Select.TEACHPRONOUN
{
	if asleep != 1
	{
		"\0%(lsto)* What pronouns do you want?\w5\n\n[half]\_q/
		\![*]\q[He-His-Him,choicemasc]\n/
		\![*]\q[She-Her-Her,choicefem]\n/	
		\![*]\q[They-Their-Them,choiceneither]\e"
	}
	else
	{
		"\0\f[italic,true]"
		--
		"You cannot change your pronouns, she's asleep."
		"That's not the right moment, you know ?"
		"She cannot hear what pronouns you want to use when she is asleep."
		--
		"\f[italic,false]\x\![raise,OnChoiceSelect,configmenu]"
	}
}

Select.choicemasc
{
	presuffix = "masculine"
	himher = "him"
	heshe = "he"
	hisher = "his"
	--
	"%(lsto)* I will use he, him and his.\e"
	//Leave the part above the double dashes alone. You can replace the snip of dialogue however with whatever you like.
}

Select.choicefem
{
	presuffix = "feminine"
	himher = "her"
	heshe = "she"
	hisher = "her"
	--
	"%(lsto)* I will use she, her and her.\e"
	//as above, you can also replace this dialogue.
}

Select.choiceneither
{
	presuffix = "undefine"
	himher = "them"
	heshe = "they"
	hisher = "their"
	--
	"%(lsto)* I will use they, them and their.\e"
	//and this one.
}


//These two options toggle whether or not you can delete your ghost. Leave them alone.

Select.deleteonoff
{
	if deleteshitai == "OFF"
	{
		deleteshitai = "ON"
	}
	else
	{
		deleteshitai = "OFF"
	}
	--
	TalkConfig
}

Select.deleteoff
{
	deleteshitai = "OFF"
	TalkConfig
}


//This next set of functions handles inputting the user's birthday.

Select.TEACHBDAY
	{
		dayslot = GetDaySlot //This is setting up in case today is the user's birthday.
		
		if asleep != 1
		{
			"\0%(lsto)* What month were you born? \w8Write the number.\![open,inputbox,OnUserBornMonth,-1]\e"
		}
		else
		{
			"\0\f[italic,true]"
			--
			"You cannot teach her your birthday, she's asleep."
			"That's not the right moment, you know ?"
			"She cannot hear what is your birthday when she is asleep."
			--
			"\f[italic,false]\x\![raise,OnChoiceSelect,configmenu]"
		}
		
		//You can replace the dialogue up to the \![open,inputbox,OnUserBornMonth,-1] tag, leave that alone. You'll need the input box to get the information. Note that the month HAS to be put in in number format as well, so you might want to have your ghost mention that.
		
		//*********************Advanced User Info*******************************
		//I also touched on this in bootend.dic and explained it in the walkthrough page on coding, but I'll also go into it here. I'm going to break down the tag there at the end of the sentence so you know what it's doing. Basically, \! means a function is going to happen, open tells it to open something, inputbox tells it to open an input box, and OnUserBornMonth is the function the input box will be linked to, which is just below here. -1 means the input box should not time out. If you want to add input boxes to some new function for whatever reason, you should follow this basic format.
		//On a related note, you can raise any function at the end of any piece of dialogue by using this format - ![raise,InsertFunctionName]. This can be handy for testing things if the function is hard to get to run otherwise.
		//***********************************************************************
	}

//--OnUserBornMonth
//This takes the value that the user put into the input box above and evaluates it.

OnUserBornMonth
	{
		_tempmonth = reference0 //this stores what the user input in as a variable called _tempmonth
		if _tempmonth >= 1 && _tempmonth <= 12 //if the month is a valid month
			{
			bornmonth = _tempmonth
			bornmonthprint = Printmonth
			
			"%(lsto)* So you were born in %(bornmonthprint).\n\w8* What day was it?\![open,inputbox,OnUserBornDay,-1]\e"
			
			//Here you can see the use of a bornmonthprint envelope to show the user what month they put in. Notice that it opens an inputbox at the end the same way the one above did. You can replace the dialogue up to the input box just as with above.
			}
		else //if the month isn't a valid month, like 32 or something.
			{
			"%(lsto)* That's not a valid month. Try again.\![open,inputbox,OnUserBornMonth,-1]\e"
			
			//You can replace this dialogue as well up to the \! tag, as mentioned. You need to leave the tag for the input box so they can put in a correct month.
			}
	}

//This puts the name to the number of the month. No need to mess with these.
Printmonth
{
	if bornmonth == 1
	{
		"January"
	}
	elseif bornmonth == 2
	{
		"February"
	}
	elseif bornmonth == 3
	{
		"March"
	}
	elseif bornmonth == 4
	{
		"April"
	}
	elseif bornmonth == 5
	{
		"May"
	}
	elseif bornmonth == 6
	{
		"June"
	}
	elseif bornmonth == 7
	{
		"July"
	}
	elseif bornmonth == 8
	{
		"August"
	}
	elseif bornmonth == 9
	{
		"September"
	}
	elseif bornmonth == 10
	{
		"October"
	}
	elseif bornmonth == 11
	{
		"November"
	}
	else
	{
		"December"
	}
}

//This adds an appropriate suffix to the number for the day. No need to mess with this either.

Printday
{
	if bornday == 1 || bornday == 21 || bornday == 31
	{
	"%(bornday)st"
	}
	elseif bornday == 2 || bornday == 22
	{
	"%(bornday)nd"
	}
	elseif bornday == 3 || bornday == 23
	{
	"%(bornday)rd"
	}
	else
	{
	"%(bornday)th"
	}
}	

//--OnUserBornDay
//This is much like the above function OnUserBornMonth. It'll take the value the user put in for the day and analyze it.

OnUserBornDay
{
	tempday = reference0 //storing the input in tempday
	
	if bornmonth == 1 || bornmonth == 3 || bornmonth == 5 || bornmonth == 7 || bornmonth == 8 || bornmonth == 10 || bornmonth == 12 //This is checking to see if it's one of the months with 31 days.
		{
			if tempday >= 1 && tempday <= 31 //if it falls in the right range
				{
					bornday = tempday
					borndayprint = Printday
					userbirthday = "%(bornmonth)month %(bornday)day"
					birthdayprint = "%(bornmonthprint) %(borndayprint)"
					
					"%(birthchecked)"
					//Mostly defining envelopes and values in here. No need to touch any of this! Eagle-eyed readers will notice the new envelope birthchecked on its own line like a tiny king. We'll get to that momentarily, but pay it no mind for now.
				}
			else //if the day isn't valid, like the 10046th or something.
				{
					"\0%(lsto)* That's not a valid day. Try again.\![open,inputbox,OnUserBornDay,-1]\e"
					
					//Similar as you can see to the month check above. You can replace the dialogue here up to the tag as you just did, but make sure to leave the input box tag so the user can put in a correct day.
				}
		}
	elseif bornmonth == 2 //if the month is february
		{
			if tempday >= 1 && tempday <= 29 //and the day falls in the right range
				{
					bornday = tempday
					borndayprint = Printday
					userbirthday = "%(bornmonth)month %(bornday)day"
					birthdayprint = "%(bornmonthprint) %(borndayprint)"
					
					"%(birthchecked)"
					//just as with the above.
				}
			else
				{
					"\0%(lsto)* That's not a valid day. Try again.\![open,inputbox,OnUserBornDay,-1]\e"
					
					//And the same as above again! You see the pattern here?
				}
		}
	else //if it's any other month than those
		{
			if tempday >= 1 && tempday <= 30 //if the day falls between these values
				{
					bornday = tempday
					borndayprint = Printday
					userbirthday = "%(bornmonth)month %(bornday)day"
					birthdayprint = "%(bornmonthprint) %(borndayprint)"
					
					"%(birthchecked)"
				}
			else
				{
					"\0%(lsto)* That's not a valid day. Try again.\![open,inputbox,OnUserBornDay,-1]\e"
				}
		}		
}

//--birthchecked
//This is the new envelope you saw me point out above. As you can see here, you can actually call dialogue in a function with an envelope, even when it has if and else statements like here! Which can be pretty handy. Again, more on envelopes in word.dic. Creative ghostmakers can find handy ways to exploit this, I'm sure.

birthchecked
{
	if userbirthday == dayslot //if today is the user's birthday
		{
			"\0* It's your birthday today.\w7 Happy birthday, %(username).\e"
			//replace this dialogue with whatever you like
		}
	elseif userbirthday == "12month 25day"
		{
			"\0* You were born on Christmas. \w7It's sad to have presents only once per year.\e"
			//As you can see, you can set up an elseif statement to check if the user's birthday is any day you want! More on elseif statements in bootend.dic. In this case, there's specialized dialogue if the user was born on Christmas. You can replace this with whatever you like, or change the date you're checking as well, like to one of your character's birthdays if you want. You can also delete this elseif if you don't care.
		}
	else //if the birthday is not listed above.
		{
			"\0* Your birthday is %(bornmonthprint) %(borndayprint).\w7 I'll remember.\e"
			//note the use of envelopes to display the newly set birthday properly. You can replace this dialogue as well, and you can use %(bornmonthprint) and %(borndayprint) to display the month and day in the new dialogue, if you want.
		}
}

//--Talk Rate
//This is when the user chooses to adjust the talk rate in the config menu. The talk rate is how often the ghost will read some dialogue from aitalk.dic.

Select.talkinter
 	{
		if asleep != 1
		{
			"\0\b2%(lsto)* How often do you want me to speak ?\w7 For now I speak every %(talktime).\n\n[half]/
			//note the new envelope here for %(talktime). You'll see it again in a second. You can replace the dialogue above with whatever you like, just make sure it ends with ./ and not \e.
			\![*]\q[Every 30 seconds,TALKMAX]\n/
			\![*]\q[Every minute,TALKHIGH]\n/
			\![*]\q[Every 3 minutes,TALKNORMAL]\n/
			\![*]\q[Every 5 minutes,TALKPOOR]\n/
			\![*]\q[Don't speak,TALKNONE]\n/
			\![*]\q[No change,TalksTill]\e"
		}
		else
		{
			"\0\f[italic,true]"
			--
			"You cannot change her talk rate, she's asleep."
			"That's not the right moment, you know ?"
			"She cannot hear the new talk rate when she is asleep."
			--
			"\f[italic,false]\x\![raise,OnChoiceSelect,configmenu]"
		}
	}

	
//If the user doesn't want to change the rate. You can change all of the dialogue in any of these options if you want to reflect the choice the user made. You TECHNICALLY could also change the value in talktime to reflect some other way of measuring time but I would NOT recommend it, it'd just be confusing I'm sure.
Select.TalksTill
	{
		"%(lsto)* Well,\w5 ok.\e"
	}

//If the user chooses every 30 seconds.
Select.TALKMAX
	{
 		talktime = "30 seconds" //this sets up the envelope properly
		aitalkinterval = 45 //this changes the actual rate
		
 		"%(lsto)* 30 seconds,\w5 huh ? \w7I will speak a lot,\w5 lol.\e"
	}

//If the user chooses every minute.
Select.TALKHIGH
	{
 		talktime = "minute"
		aitalkinterval = 90
		
 		"\0%(lsto)* I will speak every minute, \w5so often.\e"
	}

//If the user chooses every three minutes.
Select.TALKNORMAL
	{
 		talktime = "3 minutes"
		aitalkinterval = 270
		
 		"\0%(lsto)* I will speak every three minutes.\w7 It's a good talk rate for monologuing.\e"
	}

//If the user chooses every five minutes. This is the default rate the ghost will start up in, as seen in bootend.dic.
Select.TALKPOOR
	{
 		talktime = "5 minutes"
		aitalkinterval = 400
		
 		"\0%(lsto)* I will speak every five minutes.\w5 It's a relaxing talk rate.\e"
	}

//If the user chooses to not have them speak. This is one case where you MIGHT want to make talktime equal something else, if you have a snappier way of saying the ghost won't talk. Make sure it flows well in your menus though, since it will be displayed in your config menu.
Select.TALKNONE
	{
 		talktime = "...actually she doesn't talk at all"
		aitalkinterval = 0
		
		"\0%(lsto)* Huh, \w5rude.\e"
	}

	
//This is when the user chooses to change their name. It's linked to the functions outlined in nameteach.dic. Nothing to touch here.
Select.TEACHNAME
	{
		if asleep != 1
		{
			OnTeachName
		}
		else
		{
			"\0\f[italic,true]"
			--
			"You cannot teach her your name, she's asleep."
			"That's maybe not the right moment, you know ?"
			"She wouldn't remember your name if she is asleep."
			--
			"\f[italic,false]\x\![raise,OnChoiceSelect,configmenu]"
		}
	}

	
//If the user selects cancel in a menu. Replace as you like, or just leave them blank.
Select.CANCEL
	{
		if asleep != 1
		{
			"\0%(lsto)* Ok.\e"
		}
		else
		{
			"\0%(lsto)* Zzz...\e"
		}
		
 	}

	
//Going back to the MenuRun function we finished above, this is if someone selects the Functions option, linked to dosomething. As you can see, it ends up as Select.dosomething.

Select.dosomething
{
 		"\0\b2%(lsto)"
		--
		if asleep != 1
		{
			"* Do you want something ?"
		}
		else
		{
			"* Zzz..."
			"* Mmh..."
			"* Nnh..."
		}
		--
		"\n\n[half]"
		
		//I mentioned this above in MenuRun, but you can have a set of multiple different responses that may randomly appear when the menu is opened if you offset them from the rest with the -- dashes below this note. Try opening this menu yourself with the template to see how it works. The character will randomly choose one line as the intro. 
		//If you don't want to deal with this, just delete the extra lines and leave one. Otherwise, replace the dialogue above as you like, but note that they don't end with \e here. You can leave the rest of this below alone.
		--
		if asleep != 1
		{
			"\![*]\q[Open calendar,CALENDAR]\n/
			\![*]\q[Check email,MailCheck]\n/
			\![*]\q[Empty recycle bin,ChoiceGarbagecan]\n/
			\![*]\q[Update Azura,keroupdatecheck]\n/
			\![*]\q[Save the dictionary in a file,CreateUserLibrary]\n/
			\![*]\q[Send a report,sendreport]\n"
		}
		--
		"\![*]\q[System information,ChoiceSystemInformation]\n/
		\![*]\q[Update information,AfterUpdate]\n/
		\![*]\q[Azura's information,AzDescript]\n/
		\![*]\q[Azura's mind about you,UserDescript]\n\n[half]/
		//\![*]\q[Report a battle bug,BattleBug]\n\n[half]/
 		\![*]\q[Back to main menu,BACKTOMENU]\e"
}

//When the user clicks Open Calender. This will open the calender function of SSP, an in-built feature that you don't have to worry about in the least.
Select.CALENDAR
{
	"\0%(lsto)* Here is the calender.\![open,calendar]\e"
	
	//You can replace the dialogue here up to the \!.
	//Advanced users, can you break it down yet? It's basically just using \! to open calender.exe or dll or whatever SSP uses to make it happen.
}

//When the user chooses SSP preferences. This will open the same window that shows up if you right click your ghost and go to Utilities - Preferences.
Select.sspconfig
{
	"\0%(lsto)* I open the SSP config menu.\![open,configurationdialog]\e"
	
	//Again, you can replace up to the \! tag.
}

//If the user chooses to empty the recycle bin.
Select.ChoiceGarbagecan
{
	_gomicheck = FUNCTIONEX("gomi.dll", "-n");	//Don't touch this line. for those curious, it's referencing a SAORI, which are optional user-made plug-in dlls you can download to enable different functions on your ghost. gomi.dll is one included with this template. All SAORI are in Japanese (maybe Korean or Chinese as well idk) and many have disappeared by now, so don't concern yourself very much with SAORI. It's just some ghost trivia, basically.
	
	if _gomicheck == 0 //If the recycle bin is empty.
	{
		"\0%(lsto)* The recycle bin was empty.\e"
		
		//This isn't the usual flat template dialogue, mostly because I wanted to show that this is a good place to use s[-1], which I covered in the walkthrough file. You can have your ghost disappear momentarily like they're going to check your recycle bin, then come back. \c clears the ghost's balloon of text. Replace dialogue as you desire.
	}
	elseif _gomicheck >= 1 //If the recycle bin is full.
	{
		"\0%(lsto)* I'm going to empty the recycle bin.\w8\w8\s[-1]\w8\w8\w8\w8\w8\![raise,OnGarbagecanEmpty]\w9\w9\w9\n\c* Done.\e"
		
		//Somewhat similar to the above, but notice the \![raise],OnGarbagecanEmpty] tag in there. That's what actually empties the recycle bin, so make sure you don't delete that tag. Otherwise, replace the dialogue as you want.
		//As you can see, you can have multiple pieces of dialogue in here, just like you can for many other functions scattered through the .dic files. If you only want the one, just delete the others, or if you want to add more, just copy and paste and write new dialogue as it comes to you. This applies to when the recycle bin is empty as well.
	}
}


//This is for the SAORI, don't touch it.
OnGarbagecanEmpty
{
	_gomi = FUNCTIONEX("gomi.dll", "-f")
}

//This is when the user chooses System Information. Don't touch any of this either. For those curious though, note that this is done using another SAORI, this time saori_cpuid.dll.
Select.ChoiceSystemInformation
{
	os_name = FUNCTIONEX("saori_cpuid.dll","os.name");
	os_version = FUNCTIONEX("saori_cpuid.dll","os.version");
	cpu_name = FUNCTIONEX("saori_cpuid.dll","cpu.name");
	cpu_clockex = FUNCTIONEX("saori_cpuid.dll","cpu.clockex");
	"/
	\0\b[2]/
	\_q\f[bold,1]OS:\f[bold,0] %(os_name) %(os_version)\n/
	\f[bold,1]Memory Load:\f[bold,0] %(memoryload)%\n/
	\f[bold,1]Physical Memory:\f[bold,0] %(memoryavailphys) KB\n/
	\f[bold,1]CPU:\f[bold,0] %(cpu_name) %(cpu_clockex)MHz\n/
	\f[bold,1]Ukagaka:\f[bold,0] %property[baseware.version]/
	\e"
}
	
//This is when the user chooses to check their email. The rest of this function plays out in etc.dic. You can leave this alone.
Select.MailCheck
	{
		"\![biff]\e"
	}


//This is when the user ends their headline session. Headlines are detailed more in etc.dic. Replace dialogue with what strikes you.
Select.HEADLINECANCEL
 	{
 		"\0%(lsto)* Finished with headlines.\e"
	}

	
//---- OnChoiceTimeout ---------------------------------------------------------
//If the user is given a menu with choices, but doesn't pick one of the choices, it will eventually time out. At that point, they will say this dialogue. Replace with whatever you like, or leave it blank.

OnChoiceTimeout
 {
	"\0%(lsta)She stopped looking at you.\f[italic,false]\e"
	"\0%(lsta)Seems that you took too long to make your choice.\f[italic,false]"
	"\0%(lsta)She is thinking you forget her.\f[italic,false]"
 }

Select.sendreport
{
	"%(lsto)* What kind of report do you want to send ?\_q\n\n[half]"
	--
	"\![*]\q[Send the dictionary,senddictio]\n\![*]\q[Send a message or a feedback,sendmessage]\n\n[half]"
	--
	"\![*]\q[Go back,dosomething]     \![*]\q[Nevermind,close]"
	temp = ""
	
}
 
 Select.senddictio
 {
	 _i = FOPEN("./temp.txt","w")
	foreach nameslib ; _word {_i = FWRITE("./temp.txt",_word)}
	_i = FWRITE("./temp.txt","Adjectif")
	foreach adjectiveslib ; _word {_i = FWRITE("./temp.txt",_word)}
	_i = FWRITE("./temp.txt","Verb")
	foreach verbslib ; _word {_i = FWRITE("./temp.txt",_word)}
	_i = FCLOSE("./temp.txt")
	_j = SAORI("filetransfer.dll","upload","https","azura-levidre.000webhostapp.com/file-reception.php","./temp.txt")
	_i = FDEL("./temp.txt")
	
	"* It's done."
 }
 
 Select.sendmessage
 {
	 "%(lsto)* What message do you want to send ?"
	 --
	 "\![open,inputbox,OnSendReport,-1,%(temp)]"
 }
 
 OnSendReport
 {
	 temp = reference0
	 "%(lsto)* Will you want to send this message ?\_q\n\n[half]"
	 --
	 "%(lsta)%(reference0)\f[italic,false]"
	 --
	 "\n\n[half]\![*]\q[Yes\, go ahead,actuallysendreport]\n\![*]\q[I wanna rewrite it,sendmessage]"
	 --
	 "\n\n[half]\![*]\q[Nevermind,close]"
	 
 }
 
 Select.actuallysendreport
 {
	_i = FOPEN("./temp.txt","w")
	_i = FWRITE("./temp.txt",temp)
	_i = FCLOSE("./temp.txt")
	_j = SAORI("filetransfer.dll","upload","https","azura-levidre.000webhostapp.com/file-reception.php","./temp.txt")
	_i = FDEL("./temp.txt")
	//if "%(_j)" == "1"
	//{
		"* It's done."
	/*}
	else
	{
		"* Something's wrong,\w5 are you sure your internet is ok ?"
	}
	--
	"%(_j)"*/
	temp = ""
 }
 
//---- Secondary Character Menu ---------------------------------------------------------
//This section has to do with the menu for the second character. If you don't want your second character to have a menu, you can just delete this whole chunk.

OpenKeroMenu
 {
	
}

Select.removewhich
{
	"\0%(lsto)* What do you want to remove ?\n\n[half]"
	--
	"\![*]\q[A song,removes]    \![*]\q[A playlist,removep]"
	--
	"\n\n[half]\![*]\q[Nothing,close]\e"
}


//There are no real set things for the second character to do, really. You can mostly add whatever functions you want to them, their menu is totally free reign. In mine for example, Hunter has some games, a pseudo-FAQ for users, a bug report, an update option, and most importantly, a test variable. A lot of that is fairly complicated though, so I won't get into it here. Advanced Users can pick up Hunter and Smoker and study their menu.dic to see how I did it though, and those who read the coding page of the walkthrough and want to make their own functions can feel free to add them here. 
//For the purposes of this simple template, I'll include two options that may come in handy - an update option and a bug report option, as well as the test variable.

//If you click cancel. Replace dialogue as you want.
Select.keroCANCEL
{
	"\1\s[1]This is menu cancel dialogue.\e"
}


//This is when they select bug report. This is mostly meant to briefly give the user information about you, the creator, and how to report a problem to you. This can be handy if the person forgot where they got their ghost or how to contact you. Add whatever info you like here.
Select.bugreport
{
"\1\s[1]This is the bug report dialogue. \w5Report bugs to youremailaddress@emailprovider.com. \w5We were downloaded from \_a[http://www.whereveryoupostedthem.com/]some place\_a.\e"
}

//When clicked, this will automatically tell the ghost to check for updates. More detail on updates in etc.dic. You can leave this alone.
Select.keroupdatecheck
{
	"\![updatebymyself]\e"
}



//---Les fonctions principales--------------------------------

IncreaseAffection
{
	if useraffection >= 500
	{
		if cumuhour >= 400
		{
			useraffection += 1
		}
	}
	elseif useraffection >= 375
	{
		if cumuhour >= 300
		{
			useaffection += 1
		}
	}
	elseif useraffection >= 275
	{
		if cumuhour >= 200
		{
			useraffection += 1
		}
	}
	elseif useraffection >= 150
	{
		if cumuhour >= 100
		{
			useraffection += 1
		}
	}
	elseif useraffection >= 100
	{
		if cumuhour >= 47
		{
			useraffection += 1
		}
	}
	elseif useraffection >= 65
	{
		if cumuhour >= 25
		{
			useraffection += 1
		}
	}
	elseif useraffection >= 40
	{
		if cumuhour >= 10 && askedanime == 1 && askedbooks == 1 && askedgame == 1
		{
			useraffection += 1
		}
	}
	elseif useraffection >= 20
	{
		if cumuhour >= 4
		{
			useraffection += 1
		}
	}
	else
	{
		if cumuhour >= 1
		{
			useraffection += 1
		}
	}
}

IncreasePositiveAction
{
	_changed = 0
	if moodchange < 3
	{
		positiveaction ++
		if positiveaction >= 3
		{
			positiveaction = 0
			azfeel ++
			moodchange++
			_changed = 1
		}
	}
	_changed
}
DecreasePositiveAction
{
	if moodchange < 3
	{
		positiveaction--
		if positiveaction <= -3
		{
			positiveaction = 0
			azfeel--
			moodchange++
		}
	}
}
Select.BattleBug
{
	"\b2%(lsto)* So you encoutered a bug during a fight. \w7You can report each action that occured during the battle so Levidre eventually knows where is this bug.\w7 She knows that there is a bug and is searching it since a certain amount of time,\w5 but it's a rare bug so she didn't find it.\w7 Here are each action that you and me did during the last fight :\n\n[half]"
	--
	count = 0
	linecount = 0
	actionlist = ""
	foreach battlestat ; action
	{
		actionlist += "'%(action)'\n"
		if linecount >= 4
		{
			actionlist += "\n %(count)  -------\n"
			linecount = 0
			count += 1
		}
		else
		{
			linecount +=1
		}
	}
	--
	"%(actionlist)\n\n[half]* Can you send a screenshot of this to Levidre please ? \w7So she would eventually find this bug."
}

Select.UserDescript
{
	"\0\f[italic,true]"
	--
	if useraffection <= 20
	{
		"You're a stranger for Azura."
		
	}
	elseif useraffection <= 40
	{
		"Azura doesn't know you."
	}
	elseif useraffection <= 65
	{
		if azpunched != 0
		{
			"Azura don't know you enough but think you're violent."
		}
		else
		{
			"Azura still don't know you very well."
		}
	}
	elseif useraffection <= 100
	{
		if azpunched != 0
		{
			"Azura is thinking you're a violent person."
		}
		else
		{
			"You're beginning to know each other a little better."
		}
	}
	elseif useraffection <= 150
	{
		if azpunched != 0
		{
			"Azura considers you as a violent person."
			"Azura is knowing you as a violent person."
		}
		else
		{
			"You're beginning to know each other a little better."
			
		}
	}
	elseif useraffection <= 200
	{
		
		if azpunched != 0
		{
			"Azura doesn't want to be friend with a violent person."
		}
		else
		{
			"You're knowing each other."
			"Azura was here enough time to know you better."
		}
	}
	elseif useraffection <= 275
	{
		if azpunched != 0
		{
			"You cannot be friends anymore with her because of what you did."
		}
		else
		{
			"You're beginning to be friends."
		}
	
	}
	elseif useraffection <= 375
	{
		if azpunched != 0
		{
			"You would be friends if you hadn't punched her."
		}
		else
		{
			"You're friends"
		}
	}
	elseif useraffection <= 500
	{
		if azpunched != 0
		{
			"It's sad that you punched her."
		}
		else
		{	
			"You're close to be best friends."
		}
	}
	else
	{
		if azpunched != 0
		{
			"You cannot be closer to her because of what you did."
		}
		else
		{
			"You cannot be more friends"
		}
	}
	--
	"\n\n- Your name : %(username)\n- Your birthday : "
	--
	if bornmonthprint == "" || borndayprint == ""
	{
		"unknown of Azura"
	}
	else
	{
		"%(bornmonthprint) %(borndayprint)"
	}
	--
	"\n- Pet rates : %(azpets)\n- Punch rates : %(azpunched)\n"
	--
	if azpunched == 0
	{
		"(You never punched her, you're always being kind with her.)"
	}
	elseif azpunched <= 2
	{
		"(You punched her, you have been mean with her.)"
	}
	elseif azpunched == 3
	{
		"(You punched her enough time, you shouldn't punch her more.)"
	}
	elseif azpunched == 4
	{
		"(You punched her enough time, don't punch her more)"
	}
	elseif azpunched == 5
	{
		"(Stop punching her immediately.)"
	}
	elseif azpunched == 6
	{
		"(DON'T GO FURTHER !)"
	}
	else
	{
		"She shouldn't be still here..."
	}
	--
	"\![italic,false]\n\n[half]\![*]\q[Go back to the menu,BACKTOMENU]"
	--
	"\e"
}

Select.actmenu
{
	"\0\f[italic,true]\i[2001]What do you want to do ?\n\n[half]\_q\f[italic,false]"
	--
	"\![*]\q[Touch her wings,touchwings]\n"
	--
	"\![*]\q[Joke,joke]"
	--
	if useraffection >= 150
	{
		"\n\![*]\q[Flirt,flirt]"
	}
	--
	if useraffection >= 275
	{
		"     \![*]\q[Kiss,kiss]"
	}
	--
	if useraffection >= 100
	{
		"\n\![Sing,sing]\n"
	}
	else
	{
		"\n"
	}
	
	--
	if useraffection >= 120
	{
		"\![*]\q[Tell her your feelings,feelings]\n"
	}
	--
	"\![*]\q[Insult,insult]\n\n[half]"
	--
	"\![*]\q[Nothing,BACKTOMENU]"
}

Select.itmenu
{
	"\0\f[italic,true]\i[2001]What do you want to give her ?\f[italic,false]\_q\n\n[half]"
	--
	"\![*]\q[A little present,lipresent]\n"
	--
	"\![*]\q[A bigger present,bipresent]\n"
	--
	"\![*]\q[Some food,gifood]\n\n[half]"
	--
	"\![*]\q[Nothing,BACKTOMENU]"
}

Select.asksthg
{
	"\0%(lsta)You want to ask her about...\f[italic,false]\w5\n\n[half]\_q"
	--
	"\![*]\q[About herself,askherself]\n"
	--
	"\![*]\q[Anime,askanime]    \![*]\q[Games,askgame]\n"
	--
	"\![*]\q[Books,askbooks]"
	--
	if useraffection >= 100
	{
		"    \![*]\q[Music,askmusic]\n"
	}
	else
	{
		"\n"
	}
	--
	if nowshell == "Halloween shell"
	{
		"\![*]\q[About the pumpkin,askpumpkin]\n"
	}
	
	--
	"\![*]\q[Her journey in Undertale,askundertale]\n\n[half]"
	--
	"\![*]\q[Nothing,BACKTOMENU]\e"

}


	
//---Fonctions secondaires--------------------------

Select.todolist
{
	suppr = 0
	adddeadline = 0
	"\0%(lsta)Which list ?\f[italic,false]\n\n[half]"
	--
	" \![*]\q[The weekly list,weeklist]\n \![*]\q[The monthly list,monthlist]\n \![*]\q[The whenever list,wheneverlist]\n\n[half]\![*]\q[Go back,BACKTOMENU]    \![*]\q[Nevermind,close]\e"
}

///Functions of help--------------------------------------------------------------------------------------------------------------------------------------


Select.helpmenu
{
	"\0%(lsto)* What do you want to know ?\n\n[half]\_q"
	--
	"\![*]\q[About the music player,aboutplayer]\n\![*]\q[About the say something,aboutAI]"
	--
	if askedanime == 1 && askedbooks == 1 && askedgame == 1
	{
		//"\n\n[half]\i[2001]\f[italic,true]You feel that a bug can happen. A bug rare enough so the developer doesn't encounter it enough often to find why there is a bug and how to solve it. You can report it in the Functions menu.\i[2002]\f[italic,false]"
	}
	--
	"\n\n[half]\![*]\q[Go back,BACKTOMENU]"
}
Select.aboutplayer
{
	"%(lsto)* What about the player ?\n\n[half]\_q"
	--
	"\![*]\q[General things,aboutgenplayer]    \n\![*]\q[Bugs or advices,aboutbugs]\n\![*]\q[Voice Recognition,aboutvoice]\n\n\![*]\q[Main menu,BACKTOMENU]    \![*]\q[Nothing,close]"
}
 Select.aboutgenplayer
 {
	"\0\b2%(lsto)* I can play some musics.\w7 Almost all the music types,\w5 even the .ogg and the CDs. You can control the player with the menu, \w5the dashboard or the keyboard controls.\w7 You can choose to not use the keyboard controls or change them.\n\n[half]\w7* If you want, \w5I can save your playlist so you can switch from one playlist to an other.\e"
 }
 Select.aboutbugs
 {
	"\0\b2%(lsto)* There is a few bugs that could happen with the music player. \w7Hopefully they wouldn't occurs but it's better to know from what they can come.\w7\n* The lesser harmful bug is a song that wouldn't play. \w7There are three reason of that. \w7The first,\w5 and the more common,\w5 is a character no supported. \w7The characters no supported are , é è à â ê ä ë. The second reason why a song doesn't play is the player didn't load it correctly, \w5maybe after reloading Azura while the music was paused. \w7The last reason is the song itself.\w7 There are some songs the player wouldn't play even if this song isn't different of the others.\w7 It depends of the way the song has been downloaded.\n\n[half]* Oh,\w5 and for renaming the songs, \w5there would be t instead of some characters for the predefined title in the box because it wouldn't work with them.\e"
 }
 Select.aboutvoice
 {
	 "\0%(lsto)* SSP allows voice recognition,\w5 so you can activate it and use it to command the music player.\w7 If you want to open the voice recognition menu, just say 'Music player' and then you can tell your choice.\w7 It would act as you selected it.\w7 Though you need to tell the whole choice, \w5so for the songs,\w5 their complete name.\e"
 }
 
 Select.aboutAI
 {
	 "\![*]\q[General things,aboutAIgen]\n\![*]\q[More precisions,aboutAIprecis]\n\![*]\q[Things to avoid,aboutAIavoid]\n\n\![*]\q[Main menu,BACKTOMENU]    \![*]\q[Nothing,close]"

 } 

 Select.aboutAIgen
 {
	 "\0%(lsto)* You can say me some things by writing them in the inputbox and I will respond to you.\w7 Sometimes I wouldn't understand some things so I need you to explain me what it is.\e"
 }
 
 Select.aboutAIprecis
 {
	 "%(lsta)"
	 --
	 "Azura's AI isn't completed yet so negative sentences and questions aren't working yet. \n\n[half]If you want to help the developer, Levidre, you can send her your own dictionary. It's interesting for her to know which words people are teaching to Azura to know which ones implement. You can create the file wherever you want on your computer from the Functions menu. \nThe file created would only contain your dictionary, it's a .txt so you can look inside to see what looks like your dictionary."
 }
 
 Select.aboutAIavoid
 {
	 "\b2%(lsta)The subject and the verb must be separated, so you must avoid 'I'm' or 'they're'. The only pronoun Azura will understand without problems is 'I', she doesn't have any other pronouns in her library. You can try to teach them some but teaching pronouns hasn't been tested by the developer for now.\n\n[half]Avoid questions too, for now they aren't implemented at all so Azura wouldn't answer. Avoid negative sentences too for the same reason. Complements are understood but not some conjonctions nor linking words."
 }
 
//--Test Variable --------------------------------------------------------
//I briefly mentioned the test variable in bootend.dic and possibly in etc.dic as well, I'm not sure. What exactly is the test variable? Basically, it's a place you can plug in anything you want to test out. What this means is that you can write some ghost dialogue, then copy and paste it into the test variable dialogue snippet down there, reload your ghost, then choose "test variable" from your second character's menu. Check your dialogue to see if it looks right and if it does, put it back in aitalk, or edit it until it looks right and put it back. While you can use Script Input to test most of your ghost's dialogue, there are some lines it just can't do, and it can't help you test choices. But the test variable can! The dialogue/choices from OnFirstBoot are a prime candidate for testing with this variable.
//You can also use this to test functions as I mentioned above by adding \![raise,function] at the end of it, although you can do this with Script Input as well. Advanced Users, the test variable is also great for testing out any new stuff you may add to your ghost, like mode settings, item values, functions, raising or lowering numbers, what have you.

//It is ALWAYS A GOOD IDEA to test your dialogue! If you won't check it with the test variable, at least test it with Script Input! It'll save you so much trouble!

Select.testvariable
{
	//"\1\s[10]Testing!\e"
	
	//"\![enter,passivemode]\0\s[0]Hi, I'm Azura. \w5It's nice to meet you. \w8\0\n\n[half]It's kind of weird for me, it's the firts time I'm in a computer. \w5I don't think that being in Undetale could be considered as being inside a computer. \w5I'm sorry but I must ask you :\x\w4\0\c\s[0]How should I refer to you ?\n\n[half]/
	//	\w5\_q\![*]\q[He/Him/His,choicefirsthehim]\n/
	//	\![*]\q[She/Her/Hers,choicefirstsheher]\n/
	//	\![*]\q[They/Them/Their,choicefirsttheythem]"
	//"\![*]\q[ITEM,itmenu]\n"
	//"\0\s[0]It's VERY early. \w5Are you jogging or something like this ?\n\n[half]\![*]\q[Yes,jogyes]\n\![*]\q[No,jogno]\n\![*]\q[I work,jogwork]\e"
}